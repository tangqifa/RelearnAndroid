# 计算机运算

>   参考文献《编码：隐匿在计算机软硬件背后的语言》、《极客时间：深入理解计算机组成原理》

## 二进制

### 概念

>   概念二进制（英文：Binary system）是计算技术中广泛采用的一种数制。二进制数据是用 0 和 1 两个数码来表示的数。它的基数为 2，进位规则是“逢二进一”，借位规则是“借一当二”，由 18 世纪德国数理哲学大师莱布尼兹发现。当前的计算机系统使用的基本上是二进制系统，数据在计算机中主要是以**补码**的形式存储的。数字电子电路中，逻辑门直接采用了二进制，因此现代的计算机和依赖计算机的设备里都用到二进制，每个数字称为一个比特（bit）。

### 表示法

#### 源码

源码是最简单的机器数表示法，用最高位表示符号位，其他位存放该数的二进制的绝对值。 

以带符号位的四位二进制数为例：1010，最高位为 1 表示这是一个负数，其它三位 010，即 

```mathematica
 0 * 2^2 + 1 * 2^1 + 0 * 2^0 = 2
```

所以 1010 表示十进制数-2。

原码的表示法很简单，直观易懂，但是出现了+0 和-0的情况：

```mathematica
0001+0010=0011 	1+2=3
0000+1000=1000  +0+(-0)=-0
0001+1001=1010  1+(-1)=-2
```

以看到其实正数之间的加法通常是不会出错的，因为它就是一个很简单的二进制加法，而正数与负数相加，或负数与负数相加，就要引起莫名其妙的结果，这都是符号位引起的。0 分为+0 和-0 也是因它而起。

原码的特点：

1.  原码表示直观、易懂，与真值转换容易。
2.  原码中 0 有两种不同的表示形式，给使用带来了不便。通常 0 的原码用+0 表示，若在计算过程中出现了-0，则需要用硬件将-0 变成+0。
3.  原码表示加减运算复杂。利用原码进行两数相加运算时，首先要判别两数符号，若同号则做加法，若异号则做减法。在利用原码进行两数相减运算时，不仅要判别两数符号，使得同号相减，异号相加；还要判别两数绝对值的大小，用绝对值大的数减去绝对值小的数，取绝对值大的数的符号为结果的符号。可见，原码表示不便于实现加减运算。

#### 反码

原码最大的问题就在于一个数加上它的相反数不等于 0，于是反码的设计思想就是冲着解决这一点，既然一个负数是一个正数的相反数，那干脆用一个正数按位取反来表示负数。

反码：正数的反码还是等于原码；负数的反码就是它的原码除符号位外，按位取反。以带符号位的四位二进制数为例：3 是正数，反码与原码相同，则可以表示为 0011；-3 的原码是 1011，符号位保持不变，低三位按位取反，所以-3 的反码为 1100。 

反码的特点：

在反码表示中，用符号位表示数值的正负，形式与原码表示相同，即 0 为正；1 为负。在反码表示中，数值 0 有两种表示方法。反码的表示范围与原码的表示范围相同。反码表示在计算机中往往作为数码变换的中间环节。

#### 补码

正数的补码等于它的原码；负数的补码等于反码+1。

### 运算

**1) 逻辑“或”运算**只要有一个为 1，“或”运算的结果就为 1。仅当两个变量都为 0 时，或运算的结果才为 0。

**2) 逻辑“与”运算** 两个相“与”的逻辑变量中，只要有一个为 0，“与”运算的结果就为 0。仅当两个变量都为 1 时，“与”运算的结果才为 1。

**3) 逻辑“非”运算**逻辑变量为 0 时，“非”运算的结果为 1。逻辑变量为 1 时，“非”运算的结果为 0。

**4) 逻辑“异或”运算**“异或”运算，常用符号“”或“”来表示，其运算规则为：两个相“异或”的逻辑运算变量取值相同时，“异或”的结果为 0。取值相异时，“异或”的结果为 1，**异或运算也可以理解为无进位加**。

**5) 位移运算**位移运算是我们既陌生又熟悉的二进制操作。陌生是指不易理解且不常用，熟悉是指“别人家的开发工程师”在代码中经常使用这种方式进行高低位的截取、哈希计算，甚至运用在乘除法运算中。向右位移 1 位近似表示除以 2（如表 1-2 所示），十进制的奇数转化为二进制数后，在向右移时，最右边的 1 将被直接抹去，说明向右移对于奇数并非完全相当于除以 2。在左移<<与右移>>两种运算中，符号位均参与移动，除负数往右移动，高位补 1 之外，其他情况均在空位处补 0。

-   带符号位移运算

    |          正数/负数          |         向左移<< 1 位          |          向右移>> 1 位           |
    | :-------------------------: | :----------------------------: | :------------------------------: |
    | 正数 (35 的补码 0010 0011)  |         0100 0110 = 70         |    0001 0001 = 17（近似除 2)     |
    | 负数（-35 的补码 1101 1101) | 1011 1010 = 1 (1000101+1)= -70 | 1110 1110 = 1 (0010001 + 1)= -18 |
    | 正数 (99 的补码 0110 0011)  | 1100 0110 = -58（正数变负数）  |          0011 0001 = 49          |
    | 负数（-99 的补码 1001 1101) |  0011 1010 = 58（负数变正数）  |         1100 1110 = -50          |

    左移运算由于符号位参与向左移动，在移动后的结果中，最左位可能是 1 或者 0，即正数向左移动的结果可能是正，也可能是负；负数向左移动的结果同样可能是正，也可能是负。 对于三个大于号的>>>无符号向右移动（注意不存在<<<无符号向左移动的运算方式），当向右移动时，正负数高位均补 0，正数不断向右移动的最小值是 0，而负数不断向右移动的最小值是 1。无符号意即藐视符号位，符号位失去特权，必须像其他平常的数字一起向右移动，高位直接补 0，根本不关心是正数还是负数。此运算常用在高位转低位的场景中，如表所示分别表示向右移动 1~3 位的结果，左侧空位均补 0。

-   无符号位移运算

    |         正数/负数          |  向右移>>>1 位  | 向右移>>>2 位  | 向右移>>>3 位  |
    | :------------------------: | :-------------: | :------------: | :------------: |
    | 正数 (35 的补码 0010 0011) | 0001 0001 = 17  | 0000 1000 = 8  | 0000 0100 = 4  |
    | 负数 (35 的补码 1101 1101) | 0110 1110 = 110 | 0011 0111 = 55 | 0001 1011 = 27 |

    在实际编程中，位移运算仅作用于整形 (32 位）和长整型 (64) 数上，假如在整型数上移动的位数是字长的整数倍，无论是否带符号位以及移动方向，均为本身。因为移动的位数是一个 mod 32 的结果，即 35>>1 与 35>>33 是一样的结果。如果是长整型，mod 64，即 35<<1 与 35<<65 的结果是一样的。负数在无符号往右移动 63 位时，除最后边为 1 外，左边均为 0，达到最小值 1，如果>>>64,则为其原数值本身。

## 理解电路

前面讲过机器指令，你应该知道，所有最终执行的程序其实都是使用“0”和“1”这样的二进制代码来表示的。

我们人用纸和笔来做运算，都是用十进制，直接用十进制和我们最熟悉的符号不是最简单么？为什么计算机里我们最终要选择二进制呢？

计算机在硬件层面究竟是怎么表示二进制的，以此你就会明白，为什么计算机会选择二进制。

### 从信使到电报，我们怎么做到“千里传书”？

马拉松的故事相信你听说过。公元前490年，在雅典附近的马拉松海边，发生了波斯和希腊之间的希波战争。雅典和斯巴达领导的希腊联军胜利之后，雅典飞毛腿菲迪皮德斯跑了历史上第一个马拉松，回雅典报喜。这个时候，人们在远距离报信的时候，采用的是派人跑腿，传口信或者送信的方式。

但是，这样靠人传口信或者送信的方式，实在是太慢了。在军事用途中，信息能否更早更准确地传递出去经常是事关成败的大事。所以我们看到中国古代的军队有“击鼓进军”和“鸣金收兵”，通过打鼓和敲钲发出不同的声音，来传递军队的号令。

如果我们把军队当成一台计算机，那“金”和“鼓”就是这台计算机的“1”和“0”。我们可以通过不同的编码方式，来指挥这支军队前进、后退、转向、追击等等。

“金”和“鼓”比起跑腿传口信，固然效率更高了，但是能够传递的范围还是非常有限，超出个几公里恐怕就听不见了。于是，人们发明了更多能够往更远距离传信的方式，比如海上的灯塔、长城上的烽火台。因为光速比声速更快，传的距离也可以更远。

但是，这些传递信息的方式都面临一个问题，就是受限于只有“1”和“0”这两种信号，不能传递太复杂的信息，那电报的发明就解决了这个问题。

从信息编码的角度来说，金、鼓、灯塔、烽火台类似电报的二进制编码。电报传输的信号有两种，一种是短促的**点信号**（dot信号），一种是长一点的**划信号**（dash信号）。我们把“点”当成“1”，把“划”当成“0”。这样一来，我们的电报信号就是另一种特殊的二进制编码了。电影里最常见的电报信号是“SOS”，这个信号表示出来就是 “点点点划划划点点点”。

比起灯塔和烽火台这样的设备，电报信号有两个明显的优势。第一，信号的传输距离迅速增加。因为电报本质上是通过电信号来进行传播的，所以从输入信号到输出信号基本上没有延时。第二，输入信号的速度加快了很多。电报机只有一个按钮，按下就是输入信号，按的时间短一点，就是发出了一个“点”信号；按的时间长一些，就是一个“划”信号。只要一个手指，就能快速发送电报。

而且，制造一台电报机也非常容易。电报机本质上就是一个“**蜂鸣器+长长的电线+按钮开关**”。蜂鸣器装在接收方手里，开关留在发送方手里。双方用长长的电线连在一起。当按钮开关按下的时候，电线的电路接通了，蜂鸣器就会响。短促地按下，就是一个短促的点信号；按的时间稍微长一些，就是一个稍长的划信号。

![运算0](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggxutvjhj7j31ox0u0jwb.jpg)

### 理解继电器，给跑不动的信号续一秒

有了电报机，只要铺设好电报线路，就可以传输我们需要的讯息了。但是这里面又出现了一个新的挑战，就是随着电线的线路越长，电线的电阻就越大。当电阻很大，而电压不够的时候，即使你按下开关，蜂鸣器也不会响。

你可能要说了，我们可以提高电压或者用更粗的电线，使得电阻更小，这样就可以让整个线路铺得更长一些。但是这个再长，也没办法从北京铺设到上海吧。要想从北京把电报发到上海，我们还得想些别的办法。

对于电报来说，电线太长了，使得线路接通也没有办法让蜂鸣器响起来。那么，我们就不要一次铺太长的线路，而把一小段距离当成一个线路，也和驿站建立一个小电报站。我们在小电报站里面安排一个电报员，他听到上一个小电报站发来的信息，然后原样输入，发到下一个电报站去。这样，我们的信号就可以一段段传输下去，而不会因为距离太长，导致电阻太大，没有办法成功传输信号。为了能够实现这样**接力传输信号**，在电路里面，工程师们造了一个叫作**继电器**（Relay）的设备。

​	![运算1](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggxuv7r47sj316g0u0gwu.jpg)

**中继，其实就是不断地通过新的电源重新放大已经开始衰减的原有信号**

事实上，这个过程中，我们需要在每一阶段**原样传输信号**，所以你可以想想，我们是不是可以设计一个设备来代替这个电报员？相比使用人工听蜂鸣器的声音，来重复输入信号，利用电磁效应和磁铁，来实现这个事情会更容易。

我们把原先用来输出声音的蜂鸣器，换成一段环形的螺旋线圈，让电路封闭通上电。因为电磁效应，这段螺旋线圈会产生一个带有磁性的电磁场。我们原本需要输入的按钮开关，就可以用一块磁力稍弱的磁铁把它设在“关”的状态。这样，按下上一个电报站的开关，螺旋线圈通电产生了磁场之后，磁力就会把开关“吸”下来，接通到下一个电报站的电路。

如果我们在中间所有小电报站都用这个“**螺旋线圈+磁性开关**”的方式，来替代蜂鸣器和普通开关，而只在电报的始发和终点用普通的开关和蜂鸣器，我们就有了一个拆成一段一段的电报线路，接力传输电报信号。这样，我们就不需要中间安排人力来听打电报内容，也不需要解决因为线缆太长导致的电阻太大或者电压不足的问题了。我们只要在终点站安排电报员，听写最终的电报内容就可以了。这样是不是比之前更省事了？

事实上，继电器还有一个名字就叫作**电驿**，这个“驿”就是驿站的驿，可以说非常形象了。这个接力的策略不仅可以用在电报中，在通信类的科技产品中其实都可以用到。

比如说，你在家里用WiFi，如果你的屋子比较大，可能某些房间的信号就不好。你可以选用支持“中继”的WiFi路由器，在信号衰减的地方，增加一个WiFi设备，接收原来的WiFi信号，再重新从当前节点传输出去。这种中继对应的英文名词和继电器是一样的，也叫Relay。

再比如说，我们现在互联网使用的光缆，是用光信号来传输数据。随着距离的增长、反射次数的增加，信号也会有所衰减，我们同样要每隔一段距离，来增加一个用来重新放大信号的中继。

有了继电器之后，我们不仅有了一个能够接力传输信号的方式，更重要的是，和输入端通过开关的“开”和“关”来表示“1”和“0”一样，我们在输出端也能表示“1”和“0”了。

输出端的作用，不仅仅是通过一个蜂鸣器或者灯泡，提供一个供人观察的输出信号，通过“螺旋线圈 + 磁性开关”，使得我们有“开”和“关”这两种状态，这个“开”和“关”表示的“1”和“0”，还可以作为后续线路的输入信号，让我们开始可以通过最简单的电路，来组合形成我们需要的逻辑。

通过这些线圈和开关，我们也可以很容易地创建出 “与（AND）”“或（OR）”“非（NOT）”这样的逻辑。我们在输入端的电路上，提供串联的两个开关，只有两个开关都打开，电路才接通，输出的开关也才能接通，这其实就是模拟了计算机里面的“与”操作。

我们在输入端的电路，提供两条独立的线路到输出端，两条线路上各有一个开关，那么任何一个开关打开了，到输出端的电路都是接通的，这其实就是模拟了计算机中的“或”操作。

当我们把输出端的“螺旋线圈+磁性开关”的组合，从默认关掉，只有通电有了磁场之后打开，换成默认是打开通电的，只有通电之后才关闭，我们就得到了一个计算机中的“非”操作。输出端开和关正好和输入端相反。这个在数字电路中，也叫作**反向器**（Inverter）。

![运算2](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggxuxfcxvbj31690u04ay.jpg)

**反向器的电路，其实就是开关从默认关闭变成默认开启而已**

与、或、非的电路都非常简单，要想做稍微复杂一点的工作，我们需要很多电路的组合。不过，这也彰显了现代计算机体系中一个重要的思想，就是通过分层和组合，逐步搭建起更加强大的功能。

回到我们前面看的电报机原型，虽然一个按钮开关的电报机很“容易”操作，但是却不“方便”操作。因为电报员要熟记每一个字母对应的摩尔斯电码，并且需要快速按键来进行输入。一旦输错很难纠正。但是，因为电路之间可以通过与、或、非组合完成更复杂的功能，我们完全可以设计一个和打字机一样的电报机，每按下一个字母按钮，就会接通一部分电路，然后把这个字母的摩尔斯电码输出出去。

虽然在电报机时代，我们没有这么做，但是在计算机时代，我们其实就是这样做的。我们不再是给计算机“0”和“1”，而是通过千万个晶体管组合在一起，最终使得我们可以用“高级语言”，指挥计算机去干什么。

### 总结延伸

可以说，电报是现代计算机的一个最简单的原型。它和我们现在使用的现代计算机有很多相似之处。我们通过电路的“开”和“关”，来表示“1”和“0”。就像晶体管在不同的情况下，表现为导电的“1”和绝缘的“0”的状态。

我们通过电报机这个设备，看到了如何通过“螺旋线圈+开关”，来构造基本的逻辑电路，我们也叫门电路。一方面，我们可以通过继电器或者中继，进行长距离的信号传输。另一方面，我们也可以通过设置不同的线路和开关状态，实现更多不同的信号表示和处理方式，这些线路的连接方式其实就是我们在数字电路中所说的门电路。而这些门电路，也是我们创建CPU和内存的基本逻辑单元。我们的各种对于计算机二进制的“0”和“1”的操作，其实就是来自于门电路，叫作组合逻辑电路。

## 加法器

>   如何像搭乐高一样搭电路？

通过上面一节，计算机硬件层面设计最基本的单元，门电路。

我给你看的门电路非常简单，只能做简单的 “与（AND）”“或（OR）”“NOT（非）”和“异或（XOR）”，这样最基本的单比特逻辑运算。下面这些门电路的标识，你需要非常熟悉，后续的电路都是由这些门电路组合起来的。

![运算3](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggxv478pc1j31zq0u0adx.jpg)

这些基本的门电路，是我们计算机硬件端的最基本的“积木”，就好像乐高积木里面最简单的小方块。看似不起眼，但是把它们组合起来，最终可以搭出一个星球大战里面千年隼这样的大玩意儿。我们今天包含十亿级别晶体管的现代CPU，都是由这样一个一个的门电路组合而成的。

### 异或门和半加器

我们看到的基础门电路，输入都是两个单独的bit，输出是一个单独的bit。如果我们要对2个8 位（bit）的数，计算与、或、非这样的简单逻辑运算，其实很容易。只要连续摆放8个开关，来代表一个8位数。这样的两组开关，从左到右，上下单个的位开关之间，都统一用“与门”或者“或门”连起来，就是两个8位数的AND或者OR的运算了。

比起AND或者OR这样的电路外，要想实现整数的加法，就需要组建稍微复杂一点儿的电路了。

我们先回归一个最简单的8位的无符号整数的加法。这里的“无符号”，表示我们并不需要使用补码来表示负数。无论高位是“0”还是“1”，这个整数都是一个正数。

我们很直观就可以想到，要表示一个8位数的整数，简单地用8个bit，也就是8个像上一讲的电路开关就好了。那2个8位整数的加法，就是2排8个开关。加法得到的结果也是一个8位的整数，所以又需要1排8位的开关。要想实现加法，我们就要看一下，通过什么样的门电路，能够连接起加数和被加数，得到最后期望的和。

![运算4](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggxv5o4c5dj32dd0u0tea.jpg)

**其实加法器就是想一个办法把这三排开关电路连起来**

要做到这一点，我们先来看看，我们人在计算加法的时候一般会怎么操作。二进制的加法和十进制没什么区别，所以我们一样可以用**列竖式**来计算。我们仍然是从左到右，一位一位进行计算，只是把从逢10进1变成逢2进1。

| 加法运算 |  1   |  0   |  0   |  1   |
| :------: | :--: | :--: | :--: | :--: |
|    +     |  0   |  1   |  0   |  1   |
|   进位   |  0   |  0   |  1   |  0   |
|    和    |  1   |  1   |  1   |  0   |

你会发现，其实计算一位数的加法很简单。我们先就看最简单的个位数。输入一共是4种组合，00、01、10、11。得到的结果，也不复杂。

一方面，我们需要知道，加法计算之后的个位是什么，在输入的两位是00和11的情况下，对应的输出都应该是0；在输入的两位是10和01的情况下，输出都是1。结果你会发现，这个输入和输出的对应关系，其实就是我在上一讲留给你的思考题里面的“异或门（XOR）”。

讲与、或、非门的时候，我们很容易就能和程序里面的“AND（通常是&符号）”“ OR（通常是 | 符号）”和“ NOT（通常是 !符号）”对应起来。可能你没有想过，为什么我们会需要“异或（XOR）”，这样一个在逻辑运算里面没有出现的形式，作为一个基本电路。**其实，异或门就是一个最简单的整数加法，所需要使用的基本门电路**。

算完个位的输出还不算完，输入的两位都是11的时候，我们还需要向更左侧的一位进行进位。那这个就对应一个与门，也就是有且只有在加数和被加数都是1的时候，我们的进位才会是1。

所以，通过一个异或门计算出个位，通过一个与门计算出是否进位，我们就通过电路算出了一个一位数的加法。于是，**我们把两个门电路打包，给它取一个名字，就叫作半加器**（Half Adder）。

![运算5](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggxva9ovbaj32vo0rt0x6.jpg)



### 全加器

你肯定很奇怪，为什么我们给这样的电路组合，取名叫半加器（Half Adder）？莫非还有一个全加器（Full Adder）么？你猜得没错。半加器可以解决个位的加法问题，但是如果放到二位上来说，就不够用了。我们这里的竖式是个二进制的加法，所以如果从右往左数，第二列不是十位，我称之为“二位”。对应的再往左，就应该分别是四位、八位。

二位用一个半加器不能计算完成的原因也很简单。因为二位除了一个加数和被加数之外，还需要加上来自个位的进位信号，一共需要三个数进行相加，才能得到结果。但是我们目前用到的，无论是最简单的门电路，还是用两个门电路组合而成的半加器，输入都只能是两个bit，也就是两个开关。那我们该怎么办呢？

实际上，解决方案也并不复杂。**我们用两个半加器和一个或门，就能组合成一个全加器**。第一个半加器，我们用和个位的加法一样的方式，得到是否进位X和对应的二个数加和后的结果Y，这样两个输出。然后，我们把这个加和后的结果Y，和个位数相加后输出的进位信息U，再连接到一个半加器上，就会再拿到一个是否进位的信号V和对应的加和后的结果W。

![运算6](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggxvbnp78xj32ct0u0n4i.jpg)

**全加器就是两个半加器加上一个或门**

这个W就是我们在二位上留下的结果。我们把两个半加器的进位输出，作为一个或门的输入连接起来，只要两次加法中任何一次需要进位，那么在二位上，我们就会向左侧的四位进一位。因为一共只有三个bit相加，即使3个bit都是1，也最多会进一位。

这样，通过两个半加器和一个或门，我们就得到了一个，能够接受进位信号、加数和被加数，这样三个数组成的加法。这就是我们需要的全加器。

有了全加器，我们要进行对应的两个8 bit数的加法就很容易了。我们只要把8个全加器串联起来就好了。个位的全加器的进位信号作为二位全加器的输入信号，二位全加器的进位信号再作为四位的全加器的进位信号。这样一层层串接八层，我们就得到了一个支持8位数加法的算术单元。如果要扩展到16位、32位，乃至64位，都只需要多串联几个输入位和全加器就好了。

**8位加法器可以由8个全加器串联而成**

![运算6](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggxvcy1cb0j32ce0u0afz.jpg)

唯一需要注意的是，对于这个全加器，在个位，我们只需要用一个半加器，或者让全加器的进位输入始终是0。因为个位没有来自更右侧的进位。而最左侧的一位输出的进位信号，表示的并不是再进一位，而是表示我们的加法是否溢出了。

这也是很有意思的一点。以前我自己在了解二进制加法的时候，一直有这么个疑问，既然int这样的16位的整数加法，结果也是16位数，那我们怎么知道加法最终是否溢出了呢？因为结果也只存得下加法结果的16位数。我们并没有留下一个第17位，来记录这个加法的结果是否溢出。

看到全加器的电路设计，相信你应该明白，在整个加法器的结果中，我们其实有一个电路的信号，会标识出加法的结果是否溢出。我们可以把这个对应的信号，输出给到硬件中其他标志位里，让我们的计算机知道计算的结果是否溢出。而现代计算机也正是这样做的。这就是为什么你在撰写程序的时候，能够知道你的计算结果是否溢出在硬件层面得到的支持。

### 总结延伸

相信到这里，你应该已经体会到了，通过门电路来搭建算术计算的一个小功能，就好像搭乐高积木一样。

我们用两个门电路，搭出一个半加器，就好像我们拿两块乐高，叠在一起，变成一个长方形的乐高，这样我们就有了一个新的积木组件，柱子。我们再用两个柱子和一个长条的积木组合一下，就变成一个积木桥。然后几个积木桥串接在一起，又成了积木楼梯。

当我们想要搭建一个摩天大楼，我们需要很多很多楼梯。但是这个时候，我们已经不再关注最基础的一节楼梯是怎么用一块块积木搭建起来的。这其实就是计算机中，无论软件还是硬件中一个很重要的设计思想，**分层**。

![运算7](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggxveb24yvj31470u0djm.jpg)

从简单到复杂，我们一层层搭出了拥有更强能力的功能组件。在上面的一层，我们只需要考虑怎么用下一层的组件搭建出自己的功能，而不需要下沉到更低层的其他组件。就像你之前并没有深入学习过计算机组成原理，一样可以直接通过高级语言撰写代码，实现功能。

在硬件层面，我们通过门电路、半加器、全加器一层层搭出了加法器这样的功能组件。我们把这些用来做算术逻辑计算的组件叫作ALU，也就是算术逻辑单元。当进一步打造强大的CPU时，我们不会再去关注最细颗粒的门电路，只需要把门电路组合而成的ALU，当成一个能够完成基础计算的黑盒子就可以了。

以此类推，后面我们讲解CPU的设计和数据通路的时候，我们以ALU为一个基础单元来解释问题，也就够了。

## 乘法器

十进制中的13乘以9，计算的结果应该是117。我们通过转换成二进制，然后列竖式的办法，来看看整个计算的过程是怎样的。

|    被乘数     |      |      |      |  1   |  1   |  0   |  1   |
| :-----------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|     乘数      |  X   |      |      |  1   |  0   |  0   |  1   |
| 被乘数左移0位 |      |      |      |  1   |  1   |  0   |  1   |
|  全0左移1位   |      |      |  0   |  0   |  0   |  0   |      |
|  全0左移2位   |      |  0   |  0   |  0   |  0   |      |      |
| 被乘数左移3位 |  1   |  1   |  0   |  1   |      |      |      |
|               |  1   |  1   |  1   |  0   |  1   |  0   |  1   |

### 顺序乘法的实现过程

从列出竖式的过程中，你会发现，二进制的乘法有个很大的优点，就是这个过程你不需要背九九乘法口诀表了。因为单个位置上，乘数只能是0或者1，所以实际的乘法，就退化成了**位移和加法**。

在13×9这个例子里面，被乘数13表示成二进制是1101，乘数9在二进制里面是1001。最右边的个位是1，所以个位乘以被乘数，就是把被乘数1101复制下来。因为二位和四位都是0，所以乘以被乘数都是0，那么保留下来的都是0000。乘数的八位是1，我们仍然需要把被乘数1101复制下来。不过这里和个位位置的单纯复制有一点小小的差别，那就是要把复制好的结果向左侧移三位，然后把四位单独进行乘法加位移的结果，再加起来，我们就得到了最终的计算结果。

对应到我们之前讲的数字电路和ALU，你可以看到，最后一步的加法，我们可以用上一讲的加法器来实现。乘法因为只有“0”和“1”两种情况，所以可以做成输入输出都是4个开关，中间用1个开关，同时来控制这8个开关的方式，这就实现了二进制下的单位的乘法。

![乘法器0](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggz0g8b3u2j32440u0win.jpg)

**我们可以用一个开关来决定，下面的输出是完全复制输入，还是将输出全部设置为0**

![乘法器1](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggz0ouvs5oj32ge0u043g.jpg)

**把对应的线路错位连接，就可以起到位移的作用**

这样，你会发现，我们并不需要引入任何新的、更复杂的电路，仍然用最基础的电路，只要用不同的接线方式，就能够实现一个“列竖式”的乘法。而且，因为二进制下，只有0和1，也就是开关的开和闭这两种情况，所以我们的计算机也不需要去“背诵”九九乘法口诀表，不需要单独实现一个更复杂的电路，就能够实现乘法。

为了节约一点开关，也就是晶体管的数量。实际上，像13×9这样两个四位数的乘法，我们不需要把四次单位乘法的结果，用四组独立的开关单独都记录下来，然后再把这四个数加起来。因为这样做，需要很多组开关，如果我们计算一个32位的整数乘法，就要32组开关，太浪费晶体管了。如果我们顺序地来计算，只需要一组开关就好了。

我们先拿乘数最右侧的个位乘以被乘数，然后把结果写入用来存放计算结果的开关里面，然后，把被乘数左移一位，把乘数右移一位，仍然用乘数去乘以被乘数，然后把结果加到刚才的结果上。反复重复这一步骤，直到不能再左移和右移位置。这样，乘数和被乘数就像两列相向而驶的列车，仅仅需要简单的加法器、一个可以左移一位的电路和一个右移一位的电路，就能完成整个乘法。

![乘法器3](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggz0yzbf7cj31vj0u0n0n.jpg)

*乘法器硬件结构示意图*

你看这里画的乘法器硬件结构示意图。这里的控制测试，其实就是通过一个时钟信号，来控制左移、右移以及重新计算乘法和加法的时机。我们还是以计算13×9，也就是二进制的1101×1001来具体看。

|    步骤    |    数值    |    位移     |      |      |      |      |      |      |      |       |
| :--------: | :--------: | :---------: | ---- | :--: | ---- | :--: | :--: | :--: | :--: | :---: |
| **第一步** |   被乘数   |             |      |      |      |      |  1   |  1   |  0   |   1   |
|            |    乘数    |             |      |      |      |      |  1   |  0   |  0   | **1** |
|            |  中间结果  |             |      |      |      |      |  1   |  1   |  0   |   1   |
|            |    乘积    |             |      |      |      |      | *1*  | *1*  | *0*  |  *1*  |
| **第二步** |   被乘数   |   左移1位   |      |      |      |  1   |  1   |  0   |  1   |   0   |
|            |    乘数    |   右移1位   |      |      |      |      |      |  1   |  0   | **0** |
|            |  中间结果  |             |      |      |      |  0   |  0   |  0   |  0   |   0   |
|            | 上一步乘积 |             |      |      |      |      |  1   |  1   |  0   |   1   |
|            |    乘积    |             |      |      |      | *0*  | *1*  | *1*  | *0*  |  *1*  |
| **第三步** |   被乘数   | 继续左移1位 |      |      | 1    |  1   |  0   |  1   |  0   |   0   |
|            |    乘数    | 继续右移1位 |      |      |      |      |      |      |  1   | **0** |
|            |  中间结果  |             |      |      | 0    |  0   |  0   |  0   |  0   |   0   |
|            | 上一步乘积 |             |      |      |      |  0   |  1   |  1   |  0   |   1   |
|            |    乘积    |             |      |      | 0    |  0   |  1   |  1   |  0   |   1   |
| **第四步** |   被乘数   | 继续左移1位 |      |  1   | 1    |  0   |  1   |  0   |  0   |   0   |
|            |    乘数    | 继续右移1位 |      |      |      |      |      |      |      | **1** |
|            |  中间结果  |             |      |  1   | 1    |  0   |  1   |  0   |  0   |   0   |
|            | 上一步乘积 |             |      |      | 0    |  0   |  1   |  1   |  0   |   1   |
|            |    乘积    |  最终结果   |      |  1   | 1    |  1   |  0   |  1   |  0   |   1   |

这个计算方式虽然节约电路了，但是也有一个很大的缺点，那就是慢。

你应该很容易就能发现，在这个乘法器的实现过程里，我们其实就是把乘法展开，变成了“**加法+位移**”来实现。我们用的是4位数，所以要进行4组“位移+加法”的操作。而且这4组操作还不能同时进行。因为**下一组的加法要依赖上一组的加法后的计算结果，下一组的位移也要依赖上一组的位移的结果。这样，整个算法是“顺序”的，每一组加法或者位移的运算都需要一定的时间**。

所以，最终这个乘法的计算速度，其实和我们要计算的数的位数有关。比如，这里的4位，就需要4次加法。而我们的现代CPU常常要用32位或者是64位来表示整数，那么对应就需要32次或者64次加法。比起4位数，要多花上8倍乃至16倍的时间。

换个我们在算法和数据结构中的术语来说就是，这样的一个顺序乘法器硬件进行计算的时间复杂度是 O(N)。这里的N，就是乘法的数里面的**位数**。

### 并行加速方法

那么，我们有没有办法，把时间复杂度上降下来呢？研究数据结构和算法的时候，我们总是希望能够把O(N)的时间复杂度，降低到O(logN)。办法还真的有。和软件开发里面改算法一样，在涉及CPU和电路的时候，我们可以改电路。

32位数虽然是32次加法，但是我们可以让很多加法同时进行。回到这一讲开始，我们把位移和乘法的计算结果加到中间结果里的方法，32位整数的乘法，其实就变成了32个整数相加。

前面顺序乘法器硬件的实现办法，就好像体育比赛里面的**单败淘汰赛**。只有一个擂台会存下最新的计算结果。每一场新的比赛就来一个新的选手，实现一次加法，实现完了剩下的还是原来那个守擂的，直到其余31个选手都上来比过一场。如果一场比赛需要一天，那么一共要比31场，也就是31天。

![乘法器2](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggz1nnjh4vj31p50u0dju.jpg)

*目前的乘法实现就像是单败淘汰赛*

加速的办法，就是把比赛变成像世界杯足球赛那样的淘汰赛，32个球队捉对厮杀，同时开赛。这样一天一下子就淘汰了16支队，也就是说，32个数两两相加后，你可以得到16个结果。后面的比赛也是一样同时开赛捉对厮杀。只需要5天，也就是O(log2N)的时间，就能得到计算的结果。但是这种方式要求我们得有16个球场。因为在淘汰赛的第一轮，我们需要16场比赛同时进行。对应到我们CPU的硬件上，就是需要更多的晶体管开关，来放下中间计算结果。

![乘法器4](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggz1p5upnoj31370u0q7j.jpg)

*通过并联更多的ALU，加上更多的寄存器，我们也能加速乘法*

### 电路并行

上面我们说的并行加速的办法，看起来还是有点儿笨。我们回头来做一个抽象的思考。之所以我们的计算会慢，核心原因其实是“顺序”计算，也就是说，要等前面的计算结果完成之后，我们才能得到后面的计算结果。

最典型的例子就是我们上一讲讲的加法器。每一个全加器，都要等待上一个全加器，把对应的进入输入结果算出来，才能算下一位的输出。位数越多，越往高位走，等待前面的步骤就越多，这个等待的时间有个专门的名词，叫作**门延迟**（Gate Delay）。

每通过一个门电路，我们就要等待门电路的计算结果，就是一层的门电路延迟，我们一般给它取一个“T”作为符号。一个全加器，其实就已经有了3T的延迟（进位需要经过3个门电路）。而4位整数，最高位的计算需要等待前面三个全加器的进位结果，也就是要等9T的延迟。如果是64位整数，那就要变成63×3=189T的延迟。这可不是个小数字啊！

除了门延迟之外，还有一个问题就是**时钟频率**。在上面的顺序乘法计算里面，如果我们想要用更少的电路，计算的中间结果需要保存在寄存器里面，然后等待下一个时钟周期的到来，控制测试信号才能进行下一次移位和加法，这个延迟比上面的门延迟更可观。

那么，我们有什么办法可以解决这个问题呢？实际上，在我们进行加法的时候，如果相加的两个数是确定的，那高位是否会进位其实也是确定的。对于我们人来说，我们本身去做计算都是顺序执行的，所以要一步一步计算进位。但是，计算机是连结的各种线路。我们不用让计算机模拟人脑的思考方式，来连结线路。

那怎么才能把线路连结得复杂一点，让高位和低位的计算同时出结果呢？怎样才能让高位不需要等待低位的进位结果，而是把低位的所有输入信号都放进来，直接计算出高位的计算结果和进位结果呢？

我们只要把进位部分的电路完全展开就好了。我们的半加器到全加器，再到加法器，都是用最基础的门电路组合而成的。门电路的计算逻辑，可以像我们做数学里面的多项式乘法一样完全展开。在展开之后呢，我们可以把原来需要较少的，但是有较多层前后计算依赖关系的门电路，展开成需要较多的，但是依赖关系更少的门电路。

我在这里画了一个示意图，展示了一下我们加法器。如果我们完全展开电路，高位的进位和计算结果，可以和低位的计算结果同时获得。这个的核心原因是电路是天然并行的，一个输入信号，可以同时传播到所有接通的线路当中。

![乘法器5](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggz1u2bz7qj30u0198wm6.jpg)

*C4是前4位的计算结果是否进位的门电路表示*

如果一个4位整数最高位是否进位，展开门电路图，你会发现，我们只需要3T的延迟就可以拿到是否进位的计算结果。而对于64位的整数，也不会增加门延迟，只是从上往下复制这个电路，接入更多的信号而已。看到没？我们通过把电路变复杂，就解决了延迟的问题。

这个优化，本质上是利用了电路天然的并行性。电路只要接通，输入的信号自动传播到了所有接通的线路里面，这其实也是硬件和软件最大的不同。

无论是这里把对应的门电路逻辑进行完全展开以减少门延迟，还是上面的乘法通过并行计算多个位的乘法，都是把我们完成一个计算的电路变复杂了。而电路变复杂了，也就意味着晶体管变多了。

之前很多同学在我们讨论计算机的性能问题的时候，都提到，为什么晶体管的数量增加可以优化计算机的计算性能。实际上，这里的门电路展开和上面的并行计算乘法都是很好的例子。我们通过更多的晶体管，就可以拿到更低的门延迟，以及用更少的时钟周期完成一个计算指令。

## 浮点数和定点数

