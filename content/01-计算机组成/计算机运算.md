# 计算机运算

>   参考文献《编码：隐匿在计算机软硬件背后的语言》、《极客时间：深入理解计算机组成原理》

## 二进制

### 概念

>   概念二进制（英文：Binary system）是计算技术中广泛采用的一种数制。二进制数据是用 0 和 1 两个数码来表示的数。它的基数为 2，进位规则是“逢二进一”，借位规则是“借一当二”，由 18 世纪德国数理哲学大师莱布尼兹发现。当前的计算机系统使用的基本上是二进制系统，数据在计算机中主要是以**补码**的形式存储的。数字电子电路中，逻辑门直接采用了二进制，因此现代的计算机和依赖计算机的设备里都用到二进制，每个数字称为一个比特（bit）。

### 表示法

#### 源码

源码是最简单的机器数表示法，用最高位表示符号位，其他位存放该数的二进制的绝对值。 

以带符号位的四位二进制数为例：1010，最高位为 1 表示这是一个负数，其它三位 010，即 

```mathematica
 0 * 2^2 + 1 * 2^1 + 0 * 2^0 = 2
```

所以 1010 表示十进制数-2。

原码的表示法很简单，直观易懂，但是出现了+0 和-0的情况：

```mathematica
0001+0010=0011 	1+2=3
0000+1000=1000  +0+(-0)=-0
0001+1001=1010  1+(-1)=-2
```

以看到其实正数之间的加法通常是不会出错的，因为它就是一个很简单的二进制加法，而正数与负数相加，或负数与负数相加，就要引起莫名其妙的结果，这都是符号位引起的。0 分为+0 和-0 也是因它而起。

原码的特点：

1.  原码表示直观、易懂，与真值转换容易。
2.  原码中 0 有两种不同的表示形式，给使用带来了不便。通常 0 的原码用+0 表示，若在计算过程中出现了-0，则需要用硬件将-0 变成+0。
3.  原码表示加减运算复杂。利用原码进行两数相加运算时，首先要判别两数符号，若同号则做加法，若异号则做减法。在利用原码进行两数相减运算时，不仅要判别两数符号，使得同号相减，异号相加；还要判别两数绝对值的大小，用绝对值大的数减去绝对值小的数，取绝对值大的数的符号为结果的符号。可见，原码表示不便于实现加减运算。

#### 反码

原码最大的问题就在于一个数加上它的相反数不等于 0，于是反码的设计思想就是冲着解决这一点，既然一个负数是一个正数的相反数，那干脆用一个正数按位取反来表示负数。

反码：正数的反码还是等于原码；负数的反码就是它的原码除符号位外，按位取反。以带符号位的四位二进制数为例：3 是正数，反码与原码相同，则可以表示为 0011；-3 的原码是 1011，符号位保持不变，低三位按位取反，所以-3 的反码为 1100。 

反码的特点：

在反码表示中，用符号位表示数值的正负，形式与原码表示相同，即 0 为正；1 为负。在反码表示中，数值 0 有两种表示方法。反码的表示范围与原码的表示范围相同。反码表示在计算机中往往作为数码变换的中间环节。

#### 补码

正数的补码等于它的原码；负数的补码等于反码+1。

### 运算

**1) 逻辑“或”运算**只要有一个为 1，“或”运算的结果就为 1。仅当两个变量都为 0 时，或运算的结果才为 0。

**2) 逻辑“与”运算** 两个相“与”的逻辑变量中，只要有一个为 0，“与”运算的结果就为 0。仅当两个变量都为 1 时，“与”运算的结果才为 1。

**3) 逻辑“非”运算**逻辑变量为 0 时，“非”运算的结果为 1。逻辑变量为 1 时，“非”运算的结果为 0。

**4) 逻辑“异或”运算**“异或”运算，常用符号“”或“”来表示，其运算规则为：两个相“异或”的逻辑运算变量取值相同时，“异或”的结果为 0。取值相异时，“异或”的结果为 1，**异或运算也可以理解为无进位加**。

**5) 位移运算**位移运算是我们既陌生又熟悉的二进制操作。陌生是指不易理解且不常用，熟悉是指“别人家的开发工程师”在代码中经常使用这种方式进行高低位的截取、哈希计算，甚至运用在乘除法运算中。向右位移 1 位近似表示除以 2（如表 1-2 所示），十进制的奇数转化为二进制数后，在向右移时，最右边的 1 将被直接抹去，说明向右移对于奇数并非完全相当于除以 2。在左移<<与右移>>两种运算中，符号位均参与移动，除负数往右移动，高位补 1 之外，其他情况均在空位处补 0。

-   带符号位移运算

    |          正数/负数          |         向左移<< 1 位          |          向右移>> 1 位           |
    | :-------------------------: | :----------------------------: | :------------------------------: |
    | 正数 (35 的补码 0010 0011)  |         0100 0110 = 70         |    0001 0001 = 17（近似除 2)     |
    | 负数（-35 的补码 1101 1101) | 1011 1010 = 1 (1000101+1)= -70 | 1110 1110 = 1 (0010001 + 1)= -18 |
    | 正数 (99 的补码 0110 0011)  | 1100 0110 = -58（正数变负数）  |          0011 0001 = 49          |
    | 负数（-99 的补码 1001 1101) |  0011 1010 = 58（负数变正数）  |         1100 1110 = -50          |

    左移运算由于符号位参与向左移动，在移动后的结果中，最左位可能是 1 或者 0，即正数向左移动的结果可能是正，也可能是负；负数向左移动的结果同样可能是正，也可能是负。 对于三个大于号的>>>无符号向右移动（注意不存在<<<无符号向左移动的运算方式），当向右移动时，正负数高位均补 0，正数不断向右移动的最小值是 0，而负数不断向右移动的最小值是 1。无符号意即藐视符号位，符号位失去特权，必须像其他平常的数字一起向右移动，高位直接补 0，根本不关心是正数还是负数。此运算常用在高位转低位的场景中，如表所示分别表示向右移动 1~3 位的结果，左侧空位均补 0。

-   无符号位移运算

    |         正数/负数          |  向右移>>>1 位  | 向右移>>>2 位  | 向右移>>>3 位  |
    | :------------------------: | :-------------: | :------------: | :------------: |
    | 正数 (35 的补码 0010 0011) | 0001 0001 = 17  | 0000 1000 = 8  | 0000 0100 = 4  |
    | 负数 (35 的补码 1101 1101) | 0110 1110 = 110 | 0011 0111 = 55 | 0001 1011 = 27 |

    在实际编程中，位移运算仅作用于整形 (32 位）和长整型 (64) 数上，假如在整型数上移动的位数是字长的整数倍，无论是否带符号位以及移动方向，均为本身。因为移动的位数是一个 mod 32 的结果，即 35>>1 与 35>>33 是一样的结果。如果是长整型，mod 64，即 35<<1 与 35<<65 的结果是一样的。负数在无符号往右移动 63 位时，除最后边为 1 外，左边均为 0，达到最小值 1，如果>>>64,则为其原数值本身。

## 理解电路

## 加法器

## 乘法器

## 浮点数和定点数

