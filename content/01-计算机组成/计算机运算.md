# 计算机运算

>   参考文献《编码：隐匿在计算机软硬件背后的语言》、《极客时间：深入理解计算机组成原理》

## 二进制

### 概念

>   概念二进制（英文：Binary system）是计算技术中广泛采用的一种数制。二进制数据是用 0 和 1 两个数码来表示的数。它的基数为 2，进位规则是“逢二进一”，借位规则是“借一当二”，由 18 世纪德国数理哲学大师莱布尼兹发现。当前的计算机系统使用的基本上是二进制系统，数据在计算机中主要是以**补码**的形式存储的。数字电子电路中，逻辑门直接采用了二进制，因此现代的计算机和依赖计算机的设备里都用到二进制，每个数字称为一个比特（bit）。

### 表示法

#### 源码

源码是最简单的机器数表示法，用最高位表示符号位，其他位存放该数的二进制的绝对值。 

以带符号位的四位二进制数为例：1010，最高位为 1 表示这是一个负数，其它三位 010，即 

```mathematica
 0 * 2^2 + 1 * 2^1 + 0 * 2^0 = 2
```

所以 1010 表示十进制数-2。

原码的表示法很简单，直观易懂，但是出现了+0 和-0的情况：

```mathematica
0001+0010=0011 	1+2=3
0000+1000=1000  +0+(-0)=-0
0001+1001=1010  1+(-1)=-2
```

以看到其实正数之间的加法通常是不会出错的，因为它就是一个很简单的二进制加法，而正数与负数相加，或负数与负数相加，就要引起莫名其妙的结果，这都是符号位引起的。0 分为+0 和-0 也是因它而起。

原码的特点：

1.  原码表示直观、易懂，与真值转换容易。
2.  原码中 0 有两种不同的表示形式，给使用带来了不便。通常 0 的原码用+0 表示，若在计算过程中出现了-0，则需要用硬件将-0 变成+0。
3.  原码表示加减运算复杂。利用原码进行两数相加运算时，首先要判别两数符号，若同号则做加法，若异号则做减法。在利用原码进行两数相减运算时，不仅要判别两数符号，使得同号相减，异号相加；还要判别两数绝对值的大小，用绝对值大的数减去绝对值小的数，取绝对值大的数的符号为结果的符号。可见，原码表示不便于实现加减运算。

#### 反码

原码最大的问题就在于一个数加上它的相反数不等于 0，于是反码的设计思想就是冲着解决这一点，既然一个负数是一个正数的相反数，那干脆用一个正数按位取反来表示负数。

反码：正数的反码还是等于原码；负数的反码就是它的原码除符号位外，按位取反。以带符号位的四位二进制数为例：3 是正数，反码与原码相同，则可以表示为 0011；-3 的原码是 1011，符号位保持不变，低三位按位取反，所以-3 的反码为 1100。 

反码的特点：

在反码表示中，用符号位表示数值的正负，形式与原码表示相同，即 0 为正；1 为负。在反码表示中，数值 0 有两种表示方法。反码的表示范围与原码的表示范围相同。反码表示在计算机中往往作为数码变换的中间环节。

#### 补码

正数的补码等于它的原码；负数的补码等于反码+1。

### 运算

**1) 逻辑“或”运算**只要有一个为 1，“或”运算的结果就为 1。仅当两个变量都为 0 时，或运算的结果才为 0。

**2) 逻辑“与”运算** 两个相“与”的逻辑变量中，只要有一个为 0，“与”运算的结果就为 0。仅当两个变量都为 1 时，“与”运算的结果才为 1。

**3) 逻辑“非”运算**逻辑变量为 0 时，“非”运算的结果为 1。逻辑变量为 1 时，“非”运算的结果为 0。

**4) 逻辑“异或”运算**“异或”运算，常用符号“”或“”来表示，其运算规则为：两个相“异或”的逻辑运算变量取值相同时，“异或”的结果为 0。取值相异时，“异或”的结果为 1，**异或运算也可以理解为无进位加**。

**5) 位移运算**位移运算是我们既陌生又熟悉的二进制操作。陌生是指不易理解且不常用，熟悉是指“别人家的开发工程师”在代码中经常使用这种方式进行高低位的截取、哈希计算，甚至运用在乘除法运算中。向右位移 1 位近似表示除以 2（如表 1-2 所示），十进制的奇数转化为二进制数后，在向右移时，最右边的 1 将被直接抹去，说明向右移对于奇数并非完全相当于除以 2。在左移<<与右移>>两种运算中，符号位均参与移动，除负数往右移动，高位补 1 之外，其他情况均在空位处补 0。

-   带符号位移运算

    |          正数/负数          |         向左移<< 1 位          |          向右移>> 1 位           |
    | :-------------------------: | :----------------------------: | :------------------------------: |
    | 正数 (35 的补码 0010 0011)  |         0100 0110 = 70         |    0001 0001 = 17（近似除 2)     |
    | 负数（-35 的补码 1101 1101) | 1011 1010 = 1 (1000101+1)= -70 | 1110 1110 = 1 (0010001 + 1)= -18 |
    | 正数 (99 的补码 0110 0011)  | 1100 0110 = -58（正数变负数）  |          0011 0001 = 49          |
    | 负数（-99 的补码 1001 1101) |  0011 1010 = 58（负数变正数）  |         1100 1110 = -50          |

    左移运算由于符号位参与向左移动，在移动后的结果中，最左位可能是 1 或者 0，即正数向左移动的结果可能是正，也可能是负；负数向左移动的结果同样可能是正，也可能是负。 对于三个大于号的>>>无符号向右移动（注意不存在<<<无符号向左移动的运算方式），当向右移动时，正负数高位均补 0，正数不断向右移动的最小值是 0，而负数不断向右移动的最小值是 1。无符号意即藐视符号位，符号位失去特权，必须像其他平常的数字一起向右移动，高位直接补 0，根本不关心是正数还是负数。此运算常用在高位转低位的场景中，如表所示分别表示向右移动 1~3 位的结果，左侧空位均补 0。

-   无符号位移运算

    |         正数/负数          |  向右移>>>1 位  | 向右移>>>2 位  | 向右移>>>3 位  |
    | :------------------------: | :-------------: | :------------: | :------------: |
    | 正数 (35 的补码 0010 0011) | 0001 0001 = 17  | 0000 1000 = 8  | 0000 0100 = 4  |
    | 负数 (35 的补码 1101 1101) | 0110 1110 = 110 | 0011 0111 = 55 | 0001 1011 = 27 |

    在实际编程中，位移运算仅作用于整形 (32 位）和长整型 (64) 数上，假如在整型数上移动的位数是字长的整数倍，无论是否带符号位以及移动方向，均为本身。因为移动的位数是一个 mod 32 的结果，即 35>>1 与 35>>33 是一样的结果。如果是长整型，mod 64，即 35<<1 与 35<<65 的结果是一样的。负数在无符号往右移动 63 位时，除最后边为 1 外，左边均为 0，达到最小值 1，如果>>>64,则为其原数值本身。

## 理解电路

前面讲过机器指令，你应该知道，所有最终执行的程序其实都是使用“0”和“1”这样的二进制代码来表示的。

我们人用纸和笔来做运算，都是用十进制，直接用十进制和我们最熟悉的符号不是最简单么？为什么计算机里我们最终要选择二进制呢？

计算机在硬件层面究竟是怎么表示二进制的，以此你就会明白，为什么计算机会选择二进制。

### 从信使到电报，我们怎么做到“千里传书”？

马拉松的故事相信你听说过。公元前490年，在雅典附近的马拉松海边，发生了波斯和希腊之间的希波战争。雅典和斯巴达领导的希腊联军胜利之后，雅典飞毛腿菲迪皮德斯跑了历史上第一个马拉松，回雅典报喜。这个时候，人们在远距离报信的时候，采用的是派人跑腿，传口信或者送信的方式。

但是，这样靠人传口信或者送信的方式，实在是太慢了。在军事用途中，信息能否更早更准确地传递出去经常是事关成败的大事。所以我们看到中国古代的军队有“击鼓进军”和“鸣金收兵”，通过打鼓和敲钲发出不同的声音，来传递军队的号令。

如果我们把军队当成一台计算机，那“金”和“鼓”就是这台计算机的“1”和“0”。我们可以通过不同的编码方式，来指挥这支军队前进、后退、转向、追击等等。

“金”和“鼓”比起跑腿传口信，固然效率更高了，但是能够传递的范围还是非常有限，超出个几公里恐怕就听不见了。于是，人们发明了更多能够往更远距离传信的方式，比如海上的灯塔、长城上的烽火台。因为光速比声速更快，传的距离也可以更远。

但是，这些传递信息的方式都面临一个问题，就是受限于只有“1”和“0”这两种信号，不能传递太复杂的信息，那电报的发明就解决了这个问题。

从信息编码的角度来说，金、鼓、灯塔、烽火台类似电报的二进制编码。电报传输的信号有两种，一种是短促的**点信号**（dot信号），一种是长一点的**划信号**（dash信号）。我们把“点”当成“1”，把“划”当成“0”。这样一来，我们的电报信号就是另一种特殊的二进制编码了。电影里最常见的电报信号是“SOS”，这个信号表示出来就是 “点点点划划划点点点”。

比起灯塔和烽火台这样的设备，电报信号有两个明显的优势。第一，信号的传输距离迅速增加。因为电报本质上是通过电信号来进行传播的，所以从输入信号到输出信号基本上没有延时。第二，输入信号的速度加快了很多。电报机只有一个按钮，按下就是输入信号，按的时间短一点，就是发出了一个“点”信号；按的时间长一些，就是一个“划”信号。只要一个手指，就能快速发送电报。

而且，制造一台电报机也非常容易。电报机本质上就是一个“**蜂鸣器+长长的电线+按钮开关**”。蜂鸣器装在接收方手里，开关留在发送方手里。双方用长长的电线连在一起。当按钮开关按下的时候，电线的电路接通了，蜂鸣器就会响。短促地按下，就是一个短促的点信号；按的时间稍微长一些，就是一个稍长的划信号。

![运算0](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggxutvjhj7j31ox0u0jwb.jpg)

### 理解继电器，给跑不动的信号续一秒

有了电报机，只要铺设好电报线路，就可以传输我们需要的讯息了。但是这里面又出现了一个新的挑战，就是随着电线的线路越长，电线的电阻就越大。当电阻很大，而电压不够的时候，即使你按下开关，蜂鸣器也不会响。

你可能要说了，我们可以提高电压或者用更粗的电线，使得电阻更小，这样就可以让整个线路铺得更长一些。但是这个再长，也没办法从北京铺设到上海吧。要想从北京把电报发到上海，我们还得想些别的办法。

对于电报来说，电线太长了，使得线路接通也没有办法让蜂鸣器响起来。那么，我们就不要一次铺太长的线路，而把一小段距离当成一个线路，也和驿站建立一个小电报站。我们在小电报站里面安排一个电报员，他听到上一个小电报站发来的信息，然后原样输入，发到下一个电报站去。这样，我们的信号就可以一段段传输下去，而不会因为距离太长，导致电阻太大，没有办法成功传输信号。为了能够实现这样**接力传输信号**，在电路里面，工程师们造了一个叫作**继电器**（Relay）的设备。

​	![运算1](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggxuv7r47sj316g0u0gwu.jpg)
$$
中继，其实就是不断地通过新的电源重新放大已经开始衰减的原有信号
$$
事实上，这个过程中，我们需要在每一阶段**原样传输信号**，所以你可以想想，我们是不是可以设计一个设备来代替这个电报员？相比使用人工听蜂鸣器的声音，来重复输入信号，利用电磁效应和磁铁，来实现这个事情会更容易。

我们把原先用来输出声音的蜂鸣器，换成一段环形的螺旋线圈，让电路封闭通上电。因为电磁效应，这段螺旋线圈会产生一个带有磁性的电磁场。我们原本需要输入的按钮开关，就可以用一块磁力稍弱的磁铁把它设在“关”的状态。这样，按下上一个电报站的开关，螺旋线圈通电产生了磁场之后，磁力就会把开关“吸”下来，接通到下一个电报站的电路。

如果我们在中间所有小电报站都用这个“**螺旋线圈+磁性开关**”的方式，来替代蜂鸣器和普通开关，而只在电报的始发和终点用普通的开关和蜂鸣器，我们就有了一个拆成一段一段的电报线路，接力传输电报信号。这样，我们就不需要中间安排人力来听打电报内容，也不需要解决因为线缆太长导致的电阻太大或者电压不足的问题了。我们只要在终点站安排电报员，听写最终的电报内容就可以了。这样是不是比之前更省事了？

事实上，继电器还有一个名字就叫作**电驿**，这个“驿”就是驿站的驿，可以说非常形象了。这个接力的策略不仅可以用在电报中，在通信类的科技产品中其实都可以用到。

比如说，你在家里用WiFi，如果你的屋子比较大，可能某些房间的信号就不好。你可以选用支持“中继”的WiFi路由器，在信号衰减的地方，增加一个WiFi设备，接收原来的WiFi信号，再重新从当前节点传输出去。这种中继对应的英文名词和继电器是一样的，也叫Relay。

再比如说，我们现在互联网使用的光缆，是用光信号来传输数据。随着距离的增长、反射次数的增加，信号也会有所衰减，我们同样要每隔一段距离，来增加一个用来重新放大信号的中继。

有了继电器之后，我们不仅有了一个能够接力传输信号的方式，更重要的是，和输入端通过开关的“开”和“关”来表示“1”和“0”一样，我们在输出端也能表示“1”和“0”了。

输出端的作用，不仅仅是通过一个蜂鸣器或者灯泡，提供一个供人观察的输出信号，通过“螺旋线圈 + 磁性开关”，使得我们有“开”和“关”这两种状态，这个“开”和“关”表示的“1”和“0”，还可以作为后续线路的输入信号，让我们开始可以通过最简单的电路，来组合形成我们需要的逻辑。

通过这些线圈和开关，我们也可以很容易地创建出 “与（AND）”“或（OR）”“非（NOT）”这样的逻辑。我们在输入端的电路上，提供串联的两个开关，只有两个开关都打开，电路才接通，输出的开关也才能接通，这其实就是模拟了计算机里面的“与”操作。

我们在输入端的电路，提供两条独立的线路到输出端，两条线路上各有一个开关，那么任何一个开关打开了，到输出端的电路都是接通的，这其实就是模拟了计算机中的“或”操作。

当我们把输出端的“螺旋线圈+磁性开关”的组合，从默认关掉，只有通电有了磁场之后打开，换成默认是打开通电的，只有通电之后才关闭，我们就得到了一个计算机中的“非”操作。输出端开和关正好和输入端相反。这个在数字电路中，也叫作**反向器**（Inverter）。

![运算2](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggxuxfcxvbj31690u04ay.jpg)
$$
反向器的电路，其实就是开关从默认关闭变成默认开启而已
$$
与、或、非的电路都非常简单，要想做稍微复杂一点的工作，我们需要很多电路的组合。不过，这也彰显了现代计算机体系中一个重要的思想，就是通过分层和组合，逐步搭建起更加强大的功能。

回到我们前面看的电报机原型，虽然一个按钮开关的电报机很“容易”操作，但是却不“方便”操作。因为电报员要熟记每一个字母对应的摩尔斯电码，并且需要快速按键来进行输入。一旦输错很难纠正。但是，因为电路之间可以通过与、或、非组合完成更复杂的功能，我们完全可以设计一个和打字机一样的电报机，每按下一个字母按钮，就会接通一部分电路，然后把这个字母的摩尔斯电码输出出去。

虽然在电报机时代，我们没有这么做，但是在计算机时代，我们其实就是这样做的。我们不再是给计算机“0”和“1”，而是通过千万个晶体管组合在一起，最终使得我们可以用“高级语言”，指挥计算机去干什么。

### 总结延伸

可以说，电报是现代计算机的一个最简单的原型。它和我们现在使用的现代计算机有很多相似之处。我们通过电路的“开”和“关”，来表示“1”和“0”。就像晶体管在不同的情况下，表现为导电的“1”和绝缘的“0”的状态。

我们通过电报机这个设备，看到了如何通过“螺旋线圈+开关”，来构造基本的逻辑电路，我们也叫门电路。一方面，我们可以通过继电器或者中继，进行长距离的信号传输。另一方面，我们也可以通过设置不同的线路和开关状态，实现更多不同的信号表示和处理方式，这些线路的连接方式其实就是我们在数字电路中所说的门电路。而这些门电路，也是我们创建CPU和内存的基本逻辑单元。我们的各种对于计算机二进制的“0”和“1”的操作，其实就是来自于门电路，叫作组合逻辑电路。

## 加法器

>   如何像搭乐高一样搭电路？

通过上面一节，计算机硬件层面设计最基本的单元，门电路。

我给你看的门电路非常简单，只能做简单的 “与（AND）”“或（OR）”“NOT（非）”和“异或（XOR）”，这样最基本的单比特逻辑运算。下面这些门电路的标识，你需要非常熟悉，后续的电路都是由这些门电路组合起来的。

![运算3](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggxv478pc1j31zq0u0adx.jpg)

这些基本的门电路，是我们计算机硬件端的最基本的“积木”，就好像乐高积木里面最简单的小方块。看似不起眼，但是把它们组合起来，最终可以搭出一个星球大战里面千年隼这样的大玩意儿。我们今天包含十亿级别晶体管的现代CPU，都是由这样一个一个的门电路组合而成的。

### 异或门和半加器

我们看到的基础门电路，输入都是两个单独的bit，输出是一个单独的bit。如果我们要对2个8 位（bit）的数，计算与、或、非这样的简单逻辑运算，其实很容易。只要连续摆放8个开关，来代表一个8位数。这样的两组开关，从左到右，上下单个的位开关之间，都统一用“与门”或者“或门”连起来，就是两个8位数的AND或者OR的运算了。

比起AND或者OR这样的电路外，要想实现整数的加法，就需要组建稍微复杂一点儿的电路了。

我们先回归一个最简单的8位的无符号整数的加法。这里的“无符号”，表示我们并不需要使用补码来表示负数。无论高位是“0”还是“1”，这个整数都是一个正数。

我们很直观就可以想到，要表示一个8位数的整数，简单地用8个bit，也就是8个像上一讲的电路开关就好了。那2个8位整数的加法，就是2排8个开关。加法得到的结果也是一个8位的整数，所以又需要1排8位的开关。要想实现加法，我们就要看一下，通过什么样的门电路，能够连接起加数和被加数，得到最后期望的和。

![运算4](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggxv5o4c5dj32dd0u0tea.jpg)
$$
其实加法器就是想一个办法把这三排开关电路连起来
$$
要做到这一点，我们先来看看，我们人在计算加法的时候一般会怎么操作。二进制的加法和十进制没什么区别，所以我们一样可以用**列竖式**来计算。我们仍然是从左到右，一位一位进行计算，只是把从逢10进1变成逢2进1。

| 加法运算 |  1   |  0   |  0   |  1   |
| :------: | :--: | :--: | :--: | :--: |
|    +     |  0   |  1   |  0   |  1   |
|   进位   |  0   |  0   |  1   |  0   |
|    和    |  1   |  1   |  1   |  0   |

你会发现，其实计算一位数的加法很简单。我们先就看最简单的个位数。输入一共是4种组合，00、01、10、11。得到的结果，也不复杂。

一方面，我们需要知道，加法计算之后的个位是什么，在输入的两位是00和11的情况下，对应的输出都应该是0；在输入的两位是10和01的情况下，输出都是1。结果你会发现，这个输入和输出的对应关系，其实就是我在上一讲留给你的思考题里面的“异或门（XOR）”。

讲与、或、非门的时候，我们很容易就能和程序里面的“AND（通常是&符号）”“ OR（通常是 | 符号）”和“ NOT（通常是 !符号）”对应起来。可能你没有想过，为什么我们会需要“异或（XOR）”，这样一个在逻辑运算里面没有出现的形式，作为一个基本电路。**其实，异或门就是一个最简单的整数加法，所需要使用的基本门电路**。

算完个位的输出还不算完，输入的两位都是11的时候，我们还需要向更左侧的一位进行进位。那这个就对应一个与门，也就是有且只有在加数和被加数都是1的时候，我们的进位才会是1。

所以，通过一个异或门计算出个位，通过一个与门计算出是否进位，我们就通过电路算出了一个一位数的加法。于是，**我们把两个门电路打包，给它取一个名字，就叫作半加器**（Half Adder）。

![运算5](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggxva9ovbaj32vo0rt0x6.jpg)
$$
半加器的电路演示
$$

### 全加器

你肯定很奇怪，为什么我们给这样的电路组合，取名叫半加器（Half Adder）？莫非还有一个全加器（Full Adder）么？你猜得没错。半加器可以解决个位的加法问题，但是如果放到二位上来说，就不够用了。我们这里的竖式是个二进制的加法，所以如果从右往左数，第二列不是十位，我称之为“二位”。对应的再往左，就应该分别是四位、八位。

二位用一个半加器不能计算完成的原因也很简单。因为二位除了一个加数和被加数之外，还需要加上来自个位的进位信号，一共需要三个数进行相加，才能得到结果。但是我们目前用到的，无论是最简单的门电路，还是用两个门电路组合而成的半加器，输入都只能是两个bit，也就是两个开关。那我们该怎么办呢？

实际上，解决方案也并不复杂。**我们用两个半加器和一个或门，就能组合成一个全加器**。第一个半加器，我们用和个位的加法一样的方式，得到是否进位X和对应的二个数加和后的结果Y，这样两个输出。然后，我们把这个加和后的结果Y，和个位数相加后输出的进位信息U，再连接到一个半加器上，就会再拿到一个是否进位的信号V和对应的加和后的结果W。

![运算6](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggxvbnp78xj32ct0u0n4i.jpg)
$$
全加器就是两个半加器加上一个或门
$$
这个W就是我们在二位上留下的结果。我们把两个半加器的进位输出，作为一个或门的输入连接起来，只要两次加法中任何一次需要进位，那么在二位上，我们就会向左侧的四位进一位。因为一共只有三个bit相加，即使3个bit都是1，也最多会进一位。

这样，通过两个半加器和一个或门，我们就得到了一个，能够接受进位信号、加数和被加数，这样三个数组成的加法。这就是我们需要的全加器。

有了全加器，我们要进行对应的两个8 bit数的加法就很容易了。我们只要把8个全加器串联起来就好了。个位的全加器的进位信号作为二位全加器的输入信号，二位全加器的进位信号再作为四位的全加器的进位信号。这样一层层串接八层，我们就得到了一个支持8位数加法的算术单元。如果要扩展到16位、32位，乃至64位，都只需要多串联几个输入位和全加器就好了。

![运算6](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggxvcy1cb0j32ce0u0afz.jpg)
$$
8位加法器可以由8个全加器串联而成
$$
唯一需要注意的是，对于这个全加器，在个位，我们只需要用一个半加器，或者让全加器的进位输入始终是0。因为个位没有来自更右侧的进位。而最左侧的一位输出的进位信号，表示的并不是再进一位，而是表示我们的加法是否溢出了。

这也是很有意思的一点。以前我自己在了解二进制加法的时候，一直有这么个疑问，既然int这样的16位的整数加法，结果也是16位数，那我们怎么知道加法最终是否溢出了呢？因为结果也只存得下加法结果的16位数。我们并没有留下一个第17位，来记录这个加法的结果是否溢出。

看到全加器的电路设计，相信你应该明白，在整个加法器的结果中，我们其实有一个电路的信号，会标识出加法的结果是否溢出。我们可以把这个对应的信号，输出给到硬件中其他标志位里，让我们的计算机知道计算的结果是否溢出。而现代计算机也正是这样做的。这就是为什么你在撰写程序的时候，能够知道你的计算结果是否溢出在硬件层面得到的支持。

### 总结延伸

相信到这里，你应该已经体会到了，通过门电路来搭建算术计算的一个小功能，就好像搭乐高积木一样。

我们用两个门电路，搭出一个半加器，就好像我们拿两块乐高，叠在一起，变成一个长方形的乐高，这样我们就有了一个新的积木组件，柱子。我们再用两个柱子和一个长条的积木组合一下，就变成一个积木桥。然后几个积木桥串接在一起，又成了积木楼梯。

当我们想要搭建一个摩天大楼，我们需要很多很多楼梯。但是这个时候，我们已经不再关注最基础的一节楼梯是怎么用一块块积木搭建起来的。这其实就是计算机中，无论软件还是硬件中一个很重要的设计思想，**分层**。

![运算7](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggxveb24yvj31470u0djm.jpg)

从简单到复杂，我们一层层搭出了拥有更强能力的功能组件。在上面的一层，我们只需要考虑怎么用下一层的组件搭建出自己的功能，而不需要下沉到更低层的其他组件。就像你之前并没有深入学习过计算机组成原理，一样可以直接通过高级语言撰写代码，实现功能。

在硬件层面，我们通过门电路、半加器、全加器一层层搭出了加法器这样的功能组件。我们把这些用来做算术逻辑计算的组件叫作ALU，也就是算术逻辑单元。当进一步打造强大的CPU时，我们不会再去关注最细颗粒的门电路，只需要把门电路组合而成的ALU，当成一个能够完成基础计算的黑盒子就可以了。

以此类推，后面我们讲解CPU的设计和数据通路的时候，我们以ALU为一个基础单元来解释问题，也就够了。

## 乘法器

## 浮点数和定点数

