# 计算机性能

## 定义

我们一般把性能，定义成响应时间的倒数，也就是:

```
性能 = 1/响应时间
```

**响应时间**指的就是，我们执行一个程序，到底需要花多少时间。花的时间越少，自然性能就越好。

## 计算机的计时单位

我们简单运行一下time命令。它会返回三个值，第一个是real time，也就是我们说的Wall Clock Time，也就 是运行程序整个过程中流逝掉的时间;第二个是user time，也就是CPU在运行你的程序，在用户态运行指 令的时间;第三个是sys time，是CPU在运行你的程序，在操作系统内核里运行指令的时间。而程序实际花费的CPU执行时间(CPU Time)，就是user time加上sys time。

![time](https://tva1.sinaimg.cn/large/007S8ZIlgy1gg5qaeymfyj30ia05q74m.jpg)

然而，拿到了CPU时间，我们也不一定可以直接“比较”出两个程序的性能差异。即使在同一 台计算机上，CPU可能满载运行也可能降频运行，降频运行的时候自然花的时间会多一些。

除了CPU之外，时间这个性能指标还会受到主板、内存这些其他相关硬件的影响。所以，我们需要对“时间”这个我们可以感知的指标进行拆解，把程序的CPU执行时间变成CPU时钟周期数(CPU Cycles)和时钟周期时间(Clock Cycle)的乘积：

```
程序的CPU执行时间=CPU时钟周期数×时钟周期时间
```

我们先来理解一下什么是时钟周期时间。你在买电脑的时候，一定关注过CPU的主频。比如我手头的这台电 脑就是Intel Core-i9 2.9GHz，这里的2.9GHz就是电脑的主频(Frequency/Clock Rate)。这个 2.9GHz，我们可以先粗浅地认为，CPU在1秒时间内，可以执行的简单指令的数量是2.9G条。

![主频](https://tva1.sinaimg.cn/large/007S8ZIlgy1gg5rxdjmcmj30vu09an18.jpg)

如果想要更准确一点描述，这个2.9GHz就代表，我们CPU的一个“钟表”能够识别出来的最小的时间间隔。就像我们挂在墙上的挂钟，都是“滴答滴答”一秒一秒地走，所以通过墙上的挂钟能够识别出来的最小时间单位就是秒。

而在CPU内部，和我们平时戴的电子石英表类似，有一个叫晶体振荡器(Oscillator Crystal)的东西，简称为**晶振**。我们把晶振当成CPU内部的电子表来使用。晶振带来的每一次“滴答”，就是时钟周期时间。

在我这个2.9GHz的CPU上，这个时钟周期时间，就是1/2.9G。我们的CPU，是按照这个“时钟”提示的时间 来进行自己的操作。主频越高，意味着这个表走得越快，我们的CPU也就“被逼”着走得越快。

根据公式：

```
程序的CPU执行时间=CPU时钟周期数×时钟周期时间
```

最简单的提升性能方案，自然缩短时钟周期时间，也就是提升主频。换句话说，就是换一块好一点的CPU。 不过，这个是我们这些软件工程师控制不了的事情，所以我们就把目光挪到了乘法的另一个因子**CPU时钟周期数**上。如果能够减少程序需要的CPU时钟周期数量，一样能够提升程序性能。

对于CPU时钟周期数，我们可以再做一个分解，把它变成“指令数×每条指令的平均时钟周期数(Cycles Per Instruction，简称CPI)”。不同的指令需要的Cycles是不同的，加法和乘法都对应着一条CPU指令，但是 乘法需要的Cycles就比加法要多，自然也就慢。在这样拆分了之后，我们的程序的CPU执行时间就可以变成 这样三个部分的乘积。

```
程序的CPU执行时间=指令数×CPI×Clock Cycle Time
```

因此，如果我们想要解决性能问题，其实就是要优化这三者。

1. 时钟周期时间，就是计算机主频，这个取决于计算机硬件。我们所熟知的摩尔定律就一直在不停地提高 我们计算机的主频。比如说，我最早使用的80386主频只有33MHz，现在手头的笔记本电脑就有 2.8GHz，在主频层面，就提升了将近100倍。

2. 每条指令的平均时钟周期数CPI，就是一条指令到底需要多少CPU Cycle。在后面讲解CPU结构的时候，我 们会看到，现代的CPU通过流水线技术(Pipeline)，让一条指令需要的CPU Cycle尽可能地少。因此， 对于CPI的优化，也是计算机组成和体系结构中的重要一环。

3. 指令数，代表执行我们的程序到底需要多少条指令、用哪些指令。这个很多时候就把挑战交给了编译 器。同样的代码，编译成计算机指令时候，就有各种不同的表示方式。

我们可以把自己想象成一个CPU，坐在那里写程序。计算机主频就好像是你的打字速度，打字越快，你自然 可以多写一点程序。CPI相当于你在写程序的时候，熟悉各种快捷键，越是打同样的内容，需要敲击键盘的次数就越少。指令数相当于你的程序设计得够合理，同样的程序要写的代码行数就少。如果三者皆能实现， 你自然可以很快地写出一个优秀的程序，你的“性能”从外面来看就是好的。